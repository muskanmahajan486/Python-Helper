<img src="data:image/jpeg;base64,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" />

<center><h1>Python!</h1></center>

# Variables:

## Syntax:
- var = initialisation
    


```python
i_am_variable = 1
```


```python
i_am_variable
```




    1




```python
type(i_am_variable)
```




    int




```python
i_am_variable = "I can change my self into many Datatypes!!!"
```


```python
type(i_am_variable)
```




    str



# DataTypes
   1. Numbers:
    - int, float, complex
   2. String:
    - str
   3. Collections:
    - list, tuple, set, dict


```python
# NUMBER DATATYPE....

# int....
a = 1
print(a, "is a", type(a))

# float....
b = 1.2
print(b, "is a", type(b))

# complex....
c = 1+3j
print(c, "is a", type(c))
```

    1 is a <class 'int'>
    1.2 is a <class 'float'>
    (1+3j) is a <class 'complex'>
    


```python
# STRING DATATYPE....

# Let us get some input from the user....
in_put = input("Enter Something:")
print(in_put , "is a", type(in_put))
```

    Enter Something:1
    1 is a <class 'str'>
    

#### Oh No!!.... 
##### Every value get from the user via input() is String by default.
##### return type of input() is String....


```python
changed_input = int(input("Enter the Number:"))
print(changed_input, "is a", type(changed_input))
```

    Enter the Number:1
    1 is a <class 'int'>
    

# Collections

## Lists:
> Python knows a number of compound data types, used to group together
other values. The most versatile is the list, which can be written as a
list of comma-separated values (items) between square brackets. Lists
might contain items of different types, but usually the items all have
the same type.

> Syntax: name = [item1,.,.,itemn]


```python
squares = [1, 4, 9, 16, 25]
new_list = ["hi", 1, 10.2, 1+2j]
```


```python
new_list
```




    ['hi', 1, 10.2, (1+2j)]




```python
squares
```




    [1, 4, 9, 16, 25]




```python
squares[3] # get values by index....
```




    16




```python
squares[1:3] # get values by slicing....
```




    [4, 9]




```python
squares[:]
```




    [1, 4, 9, 16, 25]




```python
squares[::-1] # get values with steps....
```




    [25, 16, 9, 4, 1]




```python
i_am_variable
```




    'I can change my self into many Datatypes!!!'




```python
i_am_variable[::-1]
```




    '!!!sepytataD ynam otni fles ym egnahc nac I'




```python
squares[0:3:2] # start from 0 upto 3 with step 2....
```




    [1, 9]




```python
squares.append(36)
```


```python
squares
```




    [1, 4, 9, 16, 25, 36]



Check this Document for [List.](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) (OR)


```python
help(list)
```

    Help on class list in module builtins:
    
    class list(object)
     |  list() -> new empty list
     |  list(iterable) -> new list initialized from iterable's items
     |  
     |  Methods defined here:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iadd__(self, value, /)
     |      Implement self+=value.
     |  
     |  __imul__(self, value, /)
     |      Implement self*=value.
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(...)
     |      L.__reversed__() -- return a reverse iterator over the list
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(...)
     |      L.__sizeof__() -- size of L in memory, in bytes
     |  
     |  append(...)
     |      L.append(object) -> None -- append object to end
     |  
     |  clear(...)
     |      L.clear() -> None -- remove all items from L
     |  
     |  copy(...)
     |      L.copy() -> list -- a shallow copy of L
     |  
     |  count(...)
     |      L.count(value) -> integer -- return number of occurrences of value
     |  
     |  extend(...)
     |      L.extend(iterable) -> None -- extend list by appending elements from the iterable
     |  
     |  index(...)
     |      L.index(value, [start, [stop]]) -> integer -- return first index of value.
     |      Raises ValueError if the value is not present.
     |  
     |  insert(...)
     |      L.insert(index, object) -- insert object before index
     |  
     |  pop(...)
     |      L.pop([index]) -> item -- remove and return item at index (default last).
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(...)
     |      L.remove(value) -> None -- remove first occurrence of value.
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(...)
     |      L.reverse() -- reverse *IN PLACE*
     |  
     |  sort(...)
     |      L.sort(key=None, reverse=False) -> None -- stable sort *IN PLACE*
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    

## Tuple:
> Tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable

> Syntax:
    name = (item1,.,.,itemn)


```python
numbers = (1, 2, 3, 4, 5)
```


```python
numbers.append(6)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-23-bd583daa4509> in <module>
    ----> 1 numbers.append(6)
    

    AttributeError: 'tuple' object has no attribute 'append'



```python
numbers[3] = 6
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-24-a19d0fa9c717> in <module>
    ----> 1 numbers[3] = 6
    

    TypeError: 'tuple' object does not support item assignment


Check this Document for [Tuple.](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences) (OR)


```python
help(tuple)
```

    Help on class tuple in module builtins:
    
    class tuple(object)
     |  tuple() -> empty tuple
     |  tuple(iterable) -> tuple initialized from iterable's items
     |  
     |  If the argument is a tuple, the return value is the same object.
     |  
     |  Methods defined here:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __getnewargs__(...)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  count(...)
     |      T.count(value) -> integer -- return number of occurrences of value
     |  
     |  index(...)
     |      T.index(value, [start, [stop]]) -> integer -- return first index of value.
     |      Raises ValueError if the value is not present.
    
    

## Set:
> A set is an unordered collection with no duplicate elements. To create a set you have to use set(), not {}.

> Syntax : name ={item1,.,.,itemn}


```python
first_set = {1, 1, 2, 1, 8, 4, 2, 6}
```


```python
first_set
```




    {1, 2, 4, 6, 8}




```python
second_set = {1, 3, 4, 6, 8}
```


```python
first_set.intersection(second_set)
```




    {1, 4, 6, 8}



Check this Document for [Set.](https://docs.python.org/3/tutorial/datastructures.html#sets) (OR)


```python
help(set)
```

    Help on class set in module builtins:
    
    class set(object)
     |  set() -> new empty set object
     |  set(iterable) -> new set object
     |  
     |  Build an unordered collection of unique elements.
     |  
     |  Methods defined here:
     |  
     |  __and__(self, value, /)
     |      Return self&value.
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iand__(self, value, /)
     |      Return self&=value.
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __ior__(self, value, /)
     |      Return self|=value.
     |  
     |  __isub__(self, value, /)
     |      Return self-=value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __ixor__(self, value, /)
     |      Return self^=value.
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  __or__(self, value, /)
     |      Return self|value.
     |  
     |  __rand__(self, value, /)
     |      Return value&self.
     |  
     |  __reduce__(...)
     |      Return state information for pickling.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __ror__(self, value, /)
     |      Return value|self.
     |  
     |  __rsub__(self, value, /)
     |      Return value-self.
     |  
     |  __rxor__(self, value, /)
     |      Return value^self.
     |  
     |  __sizeof__(...)
     |      S.__sizeof__() -> size of S in memory, in bytes
     |  
     |  __sub__(self, value, /)
     |      Return self-value.
     |  
     |  __xor__(self, value, /)
     |      Return self^value.
     |  
     |  add(...)
     |      Add an element to a set.
     |      
     |      This has no effect if the element is already present.
     |  
     |  clear(...)
     |      Remove all elements from this set.
     |  
     |  copy(...)
     |      Return a shallow copy of a set.
     |  
     |  difference(...)
     |      Return the difference of two or more sets as a new set.
     |      
     |      (i.e. all elements that are in this set but not the others.)
     |  
     |  difference_update(...)
     |      Remove all elements of another set from this set.
     |  
     |  discard(...)
     |      Remove an element from a set if it is a member.
     |      
     |      If the element is not a member, do nothing.
     |  
     |  intersection(...)
     |      Return the intersection of two sets as a new set.
     |      
     |      (i.e. all elements that are in both sets.)
     |  
     |  intersection_update(...)
     |      Update a set with the intersection of itself and another.
     |  
     |  isdisjoint(...)
     |      Return True if two sets have a null intersection.
     |  
     |  issubset(...)
     |      Report whether another set contains this set.
     |  
     |  issuperset(...)
     |      Report whether this set contains another set.
     |  
     |  pop(...)
     |      Remove and return an arbitrary set element.
     |      Raises KeyError if the set is empty.
     |  
     |  remove(...)
     |      Remove an element from a set; it must be a member.
     |      
     |      If the element is not a member, raise a KeyError.
     |  
     |  symmetric_difference(...)
     |      Return the symmetric difference of two sets as a new set.
     |      
     |      (i.e. all elements that are in exactly one of the sets.)
     |  
     |  symmetric_difference_update(...)
     |      Update a set with the symmetric difference of itself and another.
     |  
     |  union(...)
     |      Return the union of sets as a new set.
     |      
     |      (i.e. all elements that are in either set.)
     |  
     |  update(...)
     |      Update a set with the union of itself and others.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    

## Dictionaries:
> It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: {}. Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output.

> Syntax : name {key:value}


```python
my_class = {
    "no:1" : (1, "Sam"),
    "no:2:" : (2, "Ram"),
    "no:3"  : (3, "Vicky")
}
```


```python
my_class["no:3"]
```




    (3, 'Vicky')




```python
my_class["no:1"] = (4, "Raju")
```


```python
my_class["no:1"]
```




    (4, 'Raju')




```python
my_class["no:4"] = (5, "Pavi")
```


```python
my_class
```




    {'no:1': (4, 'Raju'),
     'no:2:': (2, 'Ram'),
     'no:3': (3, 'Vicky'),
     'no:4': (5, 'Pavi')}




```python
num = [1, 2, 3, 4, 5, 6]
```


```python
squares
```




    [1, 4, 9, 16, 25, 36]




```python
num_square_zip = zip(num, squares)
```


```python
num_square_zip
```




    <zip at 0x2201ac71a08>




```python
num_square_dict = dict(num_square_zip)
```


```python
num_square_dict
```




    {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}



Check this Document for [Dict.](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) (OR)


```python
help(dict)
```

    Help on class dict in module builtins:
    
    class dict(object)
     |  dict() -> new empty dictionary
     |  dict(mapping) -> new dictionary initialized from a mapping object's
     |      (key, value) pairs
     |  dict(iterable) -> new dictionary initialized as if via:
     |      d = {}
     |      for k, v in iterable:
     |          d[k] = v
     |  dict(**kwargs) -> new dictionary initialized with the name=value pairs
     |      in the keyword argument list.  For example:  dict(one=1, two=2)
     |  
     |  Methods defined here:
     |  
     |  __contains__(self, key, /)
     |      True if D has a key k, else False.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(...)
     |      D.__sizeof__() -> size of D in memory, in bytes
     |  
     |  clear(...)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  copy(...)
     |      D.copy() -> a shallow copy of D
     |  
     |  fromkeys(iterable, value=None, /) from builtins.type
     |      Returns a new dict with keys from iterable and values equal to value.
     |  
     |  get(...)
     |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
     |  
     |  items(...)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(...)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  pop(...)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      If key is not found, d is returned if given, otherwise KeyError is raised
     |  
     |  popitem(...)
     |      D.popitem() -> (k, v), remove and return some (key, value) pair as a
     |      2-tuple; but raise KeyError if D is empty.
     |  
     |  setdefault(...)
     |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
     |  
     |  update(...)
     |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
     |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
     |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
     |      In either case, this is followed by: for k in F:  D[k] = F[k]
     |  
     |  values(...)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    

# Conditionals

1. if
2. if...else
3. if...elif...else

## If condition:
> Syntax:


```
if Condition:
      true statements....
```      


```python
num
```




    [1, 2, 3, 4, 5, 6]




```python
if 1 == num[0]:
    print("HI It's Working.....!!!!!")
```

    HI It's Working.....!!!!!
    

## if....else Condition:
> Syntax:

```
if Condition:
    true statements.....
else:
    false statements....
```


```python
if 2 == num[1]:
    print("OOpps Not Working....")
else:
    print("Yes! It's Working....")
```

    OOpps Not Working....
    

## if...elif....else Condition:
> Syntax:

```
if Condition1:
    true for Condition1 ....
elif Condition2:
    true for Condition2.....
elif Condition3:
    true for Condition3.....
else:
    false statement....
```


```python
if(1 == num[2]):
    print("It is condition1....")
elif(1 == num[1]):
    print("It is condition2....")
elif(5 == num[2]):
    print("It is condition3....")
else:
    print("It is false statement....")
```

    It is false statement....
    

# Looping..............................

## for..
## while...

### for:
> for is for get values from the collections


```python
for i in range(5):
    print(i)
else:
    print("Over...")
```

    0
    1
    2
    3
    4
    Over...
    


```python
for i in [2, 3, 4, 8, 6]:
    print(i, end=",")
```

    2,3,4,8,6,


```python
5 in [2, 3, 4, 8, 6]

```




    False



### While
> while is for condition checking loop


```python
i = 1

while True:
    print(i)
    i+=1
    if i>5:
        break
else:
    print("New one here!!!!...")
    # i++ -> not working....
```

    1
    2
    3
    4
    5
    

# Task:
## Get input from user (int) n and store first n even numbers in list


```python
in_put = int(input("Enter the number:"))
even = []
num = 1
while(len(even) < in_put):
    if(num%2 == 0):
        even.append(num)
    num+=1
print(even)
```

    Enter the number:5
    [2, 4, 6, 8, 10]
    


```python
even = []
for num in range(2, int(input("Enter the number:"))*2+1, 2):
    even.append(num)
print(even)
```

    Enter the number:5
    [2, 4, 6, 8, 10]
    


```python
inp = int(input("Enter number : "))*2+1
lis = []
for i in range(2,inp):
    if not i%2:
        lis.append(i)

        print(lis)
print(len(lis))
```

    Enter number : 5
    [2]
    [2, 4]
    [2, 4, 6]
    [2, 4, 6, 8]
    [2, 4, 6, 8, 10]
    5
    


```python
myl = [num for num in range(2, int(input("Enter the number:"))*2+1, 2)]
```

    Enter the number:5
    


```python
myl
```




    [2, 4, 6, 8, 10]



# MARK PROCESSING?

### Problem statement:

* I/P
 - 4
 - Ram 100
 - Sam 50
 - Raju 46
 - Pavi 50

* O/P
  - 100 Ram
  - 50 [Sam, Pavi]
  - 46 Raju


```python
dictionary = {}
n = int(input("Enter the limit : "))
for _ in range(n):
    name,mark = input("Enter name and Mark : ").split()
    mark = int(mark)
    if mark not in dictionary:
        dictionary[mark] = name
    else:
        dictionary[mark] += ","+name
    
for i in sorted(dictionary,reverse=True):
    if " " in dictionary[i]:
        dictionary[i] = sorted(dictionary[i].split())
    print(i,dictionary[i])
```

    Enter the limit : 5
    Enter name and Mark : ram 100
    Enter name and Mark : sanjay 50
    Enter name and Mark : pavi 50
    Enter name and Mark : pooja 100
    Enter name and Mark : sam 45
    100 ram,pooja
    50 sanjay,pavi
    45 sam
    

# Naming Convention:

* addtwonumbers

* AddTwoNumbers -> Upper Camel Case (or) Capital Case {For Classes}

* addTwoNumbers -> Lower Camel Case {For Fucntions}

* add_two_numbers -> Snake Case {For Variables}

# Spy plane

* Test case : 1
```
i/p:
6
a
a
b
c
c
b
o/p:
All Arrived!
```

* Test case : 2
```
i/p:
6
a
a
b
b
c
b
o/p:
[b,c]
```

* Test case : 3
```
i/p:
8
a
a
b
b
b
b
c
c
o/p:
All Arrived!
```

* Test case : 4
```
i/p:
5
a
a
b
c
c
o/p:
b
```


```python
# Get all plane list....
plane_arrive = []
for _ in range(int(input("Enter total number of plane: "))):
    plane_arrive.append(input("Enter the Flight Number: "))

# find Missed Plane....
missed_plane = []
for plane in set(plane_arrive):
    if plane_arrive.count(plane)%2:
        missed_plane.append(plane)
        
# Print Missed Plane....
print(missed_plane or "All Arrived")
```

    Enter total number of plane: 6
    Enter the Flight Number: 112
    Enter the Flight Number: 112
    Enter the Flight Number: 1145
    Enter the Flight Number: 125
    Enter the Flight Number: 112
    Enter the Flight Number: 112
    ['1145', '125']
    


```python
if(len(missed_plane) != 0):
    print(missed_plane)
else:
    print("All Arrived!")
```

    ['1145', '125']
    


```python
print(("All Arrived!", missed_plane)[len(missed_plane) != 0]) # (0,1)[condition]
```

    ['1145', '125']
    

# Election

* Test case : 1
```
i/p:
5
a 10
b 20
a 30
a 20
b 45
o/p:
b 65
a 60
```

* Test case : 1
```
i/p:
8
a 10
b 20
a 30
a 20
b 45
c 20
c 20
c 20
o/p:
b 65
a 60
c 60
```


```python
limit = int(input("Enter the limit : "))
total_votes = {}
for _ in range(limit):
    candidate, no_of_votes = input("Enter candidate name and No.of Votes : ").split()
    if candidate not in total_votes:
        total_votes[candidate] = 0
    total_votes[candidate] += int(no_of_votes)     
    
result = {k:v for k, v in sorted(total_votes.items(), key=lambda item:item[1], reverse=True)}
    
print(result)
```

    Enter the limit : 4
    Enter candidate name and No.of Votes : ram 100
    Enter candidate name and No.of Votes : sam 50
    Enter candidate name and No.of Votes : sam 50
    Enter candidate name and No.of Votes : sam 50
    {'sam': 150, 'ram': 100}
    


```python
total_votes.items()
```




    dict_items([('ram', 100), ('sam', 150)])



# Functions or Methods

```
def function_name():
    -----
    ------
    return value (if needed)
```

 - Code reuse!


```python
def printUpTo(number):
    for me in range(1, number+1):
        print(me)
```


```python
num = int(input("Limit: "))
printUpTo(num)
```

    Limit: 5
    1
    2
    3
    4
    5
    


```python
printUpTo(10)
```

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    


```python
def sayHiTo(name):
    return "Hello "+name
```


```python
sayHiTo("John")
```




    'Hello John'



# Lambda


```python
sayHiToUsingLambda = lambda name: "Hello "+name
```


```python
sayHiToUsingLambda("John")
```




    'Hello John'




```python
number_plus_two = lambda x,y:x+y
```


```python
n = int(input("Number : "))
print(number_plus_two(n, 2))
```

    Number : 5
    7
    

# Filter


```python
ls = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```


```python
for item in ls:
    if item%2 ==0 :
        print(item)
```

    2
    4
    6
    8
    10
    


```python
list(filter(lambda x:x%2==0,ls))
```




    [2, 4, 6, 8, 10]



# Map


```python
def plusTwo(x):
    return x+2
```


```python
list(map(plusTwo,ls))
```




    [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]




```python
list(map(lambda x:x+2,ls))
```




    [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]



# Reduce


```python
from functools import reduce
```


```python
reduce(lambda x,y:x+y,ls)
```




    55



# Excercise

- Read input as space separated
- Take odd numbers from the list
- Change odd to even
- sum of all changed even 
- find the average for that sum


```python
lst = list(map(int,input("Enter the inputs as space separated : ").split()))
```

    Enter the inputs as space separated : 1 2 5 6 10 45 21 1 3 
    


```python
print("List : ",lst)
```

    List :  [1, 2, 5, 6, 10, 45, 21, 1, 3]
    


```python
odd_lst = list(filter(lambda x: x%2,lst))
print("Odd elements from", lst, "is",odd_lst)
```

    Odd elements from [1, 2, 5, 6, 10, 45, 21, 1, 3] is [1, 5, 45, 21, 1, 3]
    


```python
even_lst = list(map(lambda x:x+1,odd_lst))
print("After converting it to Even the list look like ",even_lst)
```

    After converting it to Even the list look like  [2, 6, 46, 22, 2, 4]
    


```python
sum_of_lst = reduce(lambda x,y:x+y,even_lst)
print("Sum of all even elements ",sum_of_lst)
```

    Sum of all even elements  82
    


```python
print("Average is ",sum_of_lst/len(even_lst))
```

    Average is  13.666666666666666
    
